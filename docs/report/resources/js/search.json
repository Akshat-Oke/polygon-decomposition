[[{"l":"Polygon Decomposition","p":["This project implements the polygon decomposition and merging algorithm described in \"Algorithms for the decomposition of a polygon into convex polygons\". Specifically, the MP1 algorithm is used to decompose the non-convex polygon into convex polygons. These polygons are then merged to form and optimal decomposition consisting of the least number of convex polygons."]}],[{"l":"DCEL","p":["DCEL (Doubly-Connected Edge List) is a data structure used in computational geometry for representing planar graphs. It is mainly used for solving various geometric problems such as:","computing the intersection of two polygons,","finding the convex hull of a set of points, and","computing the Voronoi diagram of a set of points.","The DCEL data structure represents the planar graph using three main components: vertices, edges, and faces.","Vertices: A vertex is a point in space with a unique identifier. In the DCEL data structure, a vertex is represented by a vertex object that stores its coordinates and a pointer to one of the half-edges that emanates from it. This pointer is used to navigate around the graph from one vertex to another. Each vertex is incident to one or more half-edges, which are either incoming or outgoing from the vertex.","Edges: An edge is a line segment connecting two vertices. In the DCEL data structure, an edge is represented by a pair of half-edges that point in opposite directions. Each half-edge stores a pointer to its origin vertex, a pointer to its twin half-edge, a pointer to the next half-edge in the counterclockwise direction around its incident face, and a pointer to the previous half-edge in the counterclockwise direction around its origin vertex. The twin half-edge points to the other side of the edge, and the next and previous half-edges are used to navigate around the incident face.","Faces: A face is a region bounded by a set of edges. In the DCEL data structure, a face is represented by a face object that stores a pointer to one of its incident half-edges. This pointer is used to navigate around the face by following the next half-edge in the counterclockwise direction.","The DCEL data structure also includes pointers that link the vertices, edges, and faces together. Each vertex stores a pointer to one of its incident half-edges, and each half-edge stores pointers to its origin vertex, its twin half-edge, the next and previous half-edges around its origin vertex, and the incident face. The face object stores a pointer to one of its incident half-edges, which points to the next half-edge around the face.","The DCEL data structure allows efficient operations such as adding or deleting vertices, edges, or faces, and navigating around the planar graph. It also provides constant-time access to the neighboring edges of a given edge, the incident faces of a given vertex, and the edges incident to a given face."]}],[{"l":"Decomposition","p":["A convex decomposition of a polygon P is a set of convex polygons whose union gives P, and such that the intersection of any two of them, if nonempty, consists totally of edges and vertices.","- from the paper"]},{"l":"Algorithm Overview","p":["Given a non convex polygon, the algorithm picks a point as the starting point and chops off convex pieces iteratively till a convex polygon remains.","While decomposing a polygon like a star, after chopping off convex triangles we are left with the middle part that is entirely made of diagonals. This last polygon made of diagonals is stored separately as lastPolygonAdded."]},{"l":"Example"}],[{"l":"Merging","p":["The decomposition obtained by the earlier algorithm may not be optimal; containing some non essential diagonals which on removing (and henve merging the adjacent polygons) lead to a larger convex polygon, effectively decreasing the total number of convex polygons.","This is fixed by applying a merging algorithm to the previous decomposition."]},{"l":"Overview","p":["The algorithm iterates through all the diagonals, checking whether the diagonal can be removed.","A diagonal can be removed only if the diagonal's edges are not notches in the suspected \"merged\" polygon.","On removing a valid nonessential diagonal, the polygons are merged and the list of polygons updated.","This goes on till all diagonals are visited."]},{"l":"Example","p":["We see that the bottom right polygon has been merged."]}],[{"l":"Time analysis"},{"l":"Runtime vs input size","p":["Time (in microseconds) against the number of input polygon's number of vertices is plotted below.","More polygons were run in the 300-400 range, resulting in a highly varying times depending on the start time. However, we see that the general trend follows O(n^2) time complexity."]},{"l":"Time taken for various starting vertex","p":["Since the decomposition and time taken depends on the starting vertex, we ran the above polygon decomposition sequentially by taking each vertex as the starting vertex. The times taken for each run of the program is shown as a line graph.","The spike suggests that the algorithm couldn't obtain a convex polygon that started at the \"current\" vertex and had to switch start vertices multiple times. Since the switching operation takes linear time, we can see that this added up to increase the total running time for the whole decomposition."]},{"l":"Decomposition and merging times vs notches","p":["10","1000","1028","1047","1051","1056","1059","1064","1068","1084","11","1155","1167","1172","1193","1195","12","1238","1247","1285","1298","13","1333","1343","14","1437","1450","1463","1490","15","1514","1515","1542","16","1643","17","1781","1830","1868","1935","1979","1987","1990","2035","2041","2044","2056","2092","2096","2097","2151","2154","2160","2244","2263","2331","2332","2376","2402","2415","2447","2460","25","2823","2832","3052","35","3504","3674","3813","3974","3989","4089","5039","5283","529","532","535","660","850","855","858","872","880","9","906","925","984","decompose","merge","n","notches","total","We ran the algorithm on random polygons having 25 points and varying notches. Time is given for decomposition, merging and total in microseconds.","We see that the time increases with the number of notches."]}],[{"l":"Countries"},{"l":"Examples of a few countries"},{"l":"Germany"},{"l":"India"},{"l":"Spain"},{"l":"South Korea"},{"l":"Switzerland"}]]